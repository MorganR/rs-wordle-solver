##
## Reindeer Config
##
## This file sets all of Reindeer's basic configuration. This file also marks
## the top of the reindeer-managed directory, as all other paths are relative to
## this one (both paths mentioned in this file, and implicit).
##
## Reindeer is under active development, and the layout and options in this file
## may change.

# Parse Rust code to work out the precise set of source files for each crate.
# This uses `srcfiles` which only works on Rust 2018 and without some macro
# constructions. It works in almost all cases, but you may need to have a
# fixups.toml adding extra srcs if it fails.
precise_srcs = false

# Possible patterns for license files - lots of packages have them without
# registering them in the Cargo metadata, or have more than the single file it
# allows. Just look in the top-level dir for now.
license_patterns = [
  "LICENSE*", "COPYING*", "UNLICENSE*",
]

# If a fixups.toml file is needed (eg, the package has a build.rs), then
# generate a template fixups.toml to be edited.
fixup_templates = true

# Emit Cargo pkg metadata into rules (experimental, not used)
#emit_metadata = false

# Include an explicit public top-level target which depends on all other library
# targets, so that you can do a test/check build.
include_top_level = true

# Configuration for vendoring
#
# You can instead set `vendor = false` to make Reindeer-generated targets not
# build from the vendored sources, but instead download sources from crates.io
# at build time.
# To vendor:
# [vendor]
# Or:
vendor = false
# Exclude files listed in the .gitignore in this directory
# gitignore_checksum_exclude = [".gitignore"]
# Additional globs to ignore (prefer .gitignore for consistency with source
# control)
# checksum_exclude = [
# ]

# Configuration for rustsec auditing
[audit]
# Name of a package which is expected to always have an advisory to make sure
# the mechanism is working.
never_autofix = [
  "rustsec-example-crate", # never fix because this is a canary
]

# Configuration for cargo (used both for vendoring and resolving dependencies)
[cargo]
# Path to cargo, relative to this file. Can also be specified on the
# command-line. Defaults to plain "cargo".
# cargo = "path/to/cargo"

# Path to rustc, relative to this file. Can also be specified on the
# command-line. Used to set RUSTC env when invoking cargo.
# rustc = "path/to/rustc"

# Support Cargo's unstable "artifact dependencies" functionality, RFC 3028.
# This requires a version of Cargo containing
# https://github.com/rust-lang/cargo/pull/11550.
# bindeps = false

# Configuration for generated BUCK file
[buck]
# Name of the generated file
file_name = "BUCK" # default

# Rules used for various kinds of targets. These rules don't directly correspond
# with BUCK rules - they have extra attributes such as per-platform settings.
# The intent is that you provide a set of macro definitions which resolve them
# to appropriate underlying rules suitable for your environment. (This may also
# work for Buck-like build systems such as Bazel.)
rust_library = "cargo.rust_library"        # A plain Rust library
rust_binary = "cargo.rust_binary"          # A Rust executable
buildscript_genrule = "buildscript_run"    # Rule for running a build script to produce rustc args and generated sources
# cxx_library = "third_party_rust_cxx_library"    # A C++ library (mostly for Rust -> C dependencies)
# prebuilt_cxx_library = "third_party_rust_prebuilt_cxx_library"    # A prebuilt library (mostly for Rust -> C dependencies)

# Banner comment for the generated BUCK File.
generated_file_header = """
##
## \u0040generated by reindeer
## Do not edit by hand.
##
## See README.md for directions on how to update this.
##
"""

# Load the macros to which the rules above will resolve.
buckfile_imports = """
load("@prelude//rust:cargo_buildscript.bzl", "buildscript_run")
load("@prelude//rust:cargo_package.bzl", "cargo")
"""
